#Если НЕ ТонкийКлиент Тогда
///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИСПОЛЬЗУЕМЫЕ В ОБОИХ ИНТЕРФЕЙСАХ

Функция ФирмаПоТовару(Товар, КлючУникальности = "") Экспорт
	
	//:Товар = Справочники.Товары.ПустаяСсылка();
	Возврат ОбщегоНазначенияПовтИсп.ФирмаПоТоваруПовтИсп(Товар, КлючУникальности);
КонецФункции

// Определяет текущее наличие товара в продаже
//
Функция ОпределитьТекущееНаличиеВПродаже(Товар, ИзМодуляОбъекта=Ложь) Экспорт
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		ВремяСервера = ТекущаяДатаНаСервере();
	#Иначе
		ВремяСервера = ТекущаяДатаСеанса();
	#КонецЕсли
	Если Товар.ВариантНаличияВПродаже = Перечисления.ВариантыНаличияВПродаже.Простой Тогда
		Возврат Товар.ЕстьВПродаже;
		
	ИначеЕсли Товар.ВариантНаличияВПродаже = Перечисления.ВариантыНаличияВПродаже.ПростойПоИБ Тогда
		СтрокаИБ = Товар.КогдаВПродажеПоИБ.Найти(ПараметрыСеанса.ТекущаяИБ, "ИнформационнаяБаза");
		Возврат ?(СтрокаИБ=Неопределено, Ложь, СтрокаИБ.ЕстьВПродаже);
		
	КонецЕсли; 
	
	Если Товар.ВариантНаличияВПродаже = Перечисления.ВариантыНаличияВПродаже.Сложный Тогда
		КогдаВПродаже		= Товар.КогдаВПродаже;   
		КогдаВПродажеВремя1 = Товар.КогдаВПродажеВремя1;
		КогдаВПродажеВремя2 = Товар.КогдаВПродажеВремя2;
		
	Иначе // Сложный по ИБ
		СтрокаИБ = Товар.КогдаВПродажеПоИБ.Найти(ПараметрыСеанса.ТекущаяИБ, "ИнформационнаяБаза");
		Если СтрокаИБ=Неопределено Тогда
			Возврат Ложь;
		КонецЕсли; 
		
		КогдаВПродаже		= СтрокаИБ.КогдаВПродаже;
		КогдаВПродажеВремя1 = СтрокаИБ.КогдаВПродажеВремя1;
		КогдаВПродажеВремя2 = СтрокаИБ.КогдаВПродажеВремя2;
		
		// надо для динамического обновления по времени
		Если ИзМодуляОбъекта Тогда
			Товар.КогдаВПродаже			= КогдаВПродаже;
			Товар.КогдаВПродажеВремя1	= КогдаВПродажеВремя1;
			Товар.КогдаВПродажеВремя2	= КогдаВПродажеВремя2;
		КонецЕсли; 
	КонецЕсли;
	
	Если НЕ ДеньНеделиВключен(КогдаВПродаже) Тогда
		Возврат Ложь;
	ИначеЕсли НЕ ЗначениеВДиапазоне(ВремяИзДаты(ВремяСервера), КогдаВПродажеВремя1, КогдаВПродажеВремя2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Товар.ВариантНаличияВПродаже = Перечисления.ВариантыНаличияВПродаже.Сложный Тогда
		СтрокиНедели = Товар.КогдаВПродажеПоНеделям;
	Иначе // Сложный по ИБ
		СтрокиНедели = Товар.КогдаВПродажеПоНеделям.НайтиСтроки( Новый Структура("ИнформационнаяБаза", ПараметрыСеанса.ТекущаяИБ) );
	КонецЕсли;
	
	Если СтрокиНедели.Количество()=0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	ПровДата = НачалоНедели(ВремяСервера);
	
	Для каждого Неделя Из СтрокиНедели Цикл
		Если ПровДата = Неделя.ДатаПонедельника Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

// Проверяет, помечен ли указанный день недели в десятичном представлении списка дней недели
//
Функция ДеньНеделиВключен(ДниНеделиЧисло10,НомДняНедели=0) Экспорт
	
	Если НомДняНедели=0 Тогда
		НомДняНедели = ДеньНедели(ТекущаяДата());
	КонецЕсли;
	
	СтрЧисло2 = Формат( Число10в2(ДниНеделиЧисло10), "ЧВН=;ЧГ=;ЧЦ=7");
	
	Возврат Сред(СтрЧисло2,НомДняНедели,1) = "1";
	
КонецФункции

// Возвращает текущие остатки из регистра НакопленияКлиентов в виде структуры ресурсов
//
// Параметры
//  СсылкаКлиент  – <Справочник.Клиенты> – клиент
//
// Возвращаемое значение:
//   структура   – содержит значения ресурсов
//
Функция НакопленияКлиента(СсылкаКлиент, Основание=Неопределено) Экспорт
		
	Возврат Новый Структура("Клиент,СуммаБонусов,СуммаБезнал",СсылкаКлиент,0,0);
КонецФункции

// Возвращает ссылку на карту доступа по привязке
//
Функция КартаПоПривязке(СсылкаПривязка) Экспорт
	
	КартаДоступа = Справочники.КартыДоступа.НайтиПоРеквизиту("Привязка", СсылкаПривязка);
	
	Возврат КартаДоступа;
КонецФункции

// Описание функции
//
// Параметры:
//	Параметр1	- описание
//
// Возвращаемое значение:
//	Тип.Вид		- описание
//
Функция ПроверкаУникальностиРеквизитаСправочника(ПровСсылка, ИмяРеквизита, ПровЗначение) Экспорт
	
	Запрос = Новый Запрос("ВЫБРАТЬ Ссылка ИЗ Справочник."+ПровСсылка.Метаданные().Имя+"
	|ГДЕ
	|	"+ИмяРеквизита+" = &ПровЗначение И Ссылка <> &ПровСсылка");
	
	Запрос.УстановитьПараметр("ПровСсылка", ПровСсылка);
	Запрос.УстановитьПараметр("ПровЗначение", ПровЗначение);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		ПровСсылка = Выборка.Ссылка;
		Возврат Ложь;
	КонецЕсли; 
	
	Возврат Истина;
КонецФункции

// Описание функции
//
// Параметры:
//	Параметр1	- описание
//
// Возвращаемое значение:
//	Тип.Вид		- описание
//
Функция ПредставлениеСкидки(Скидка,РежимСумма=Истина) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Скидка) Тогда
		Возврат "";
		
	ИначеЕсли Скидка.ЭтоГруппа Тогда
		Возврат ?(РежимСумма, "", "сх.");
		
	ИначеЕсли ПараметрыСеанса.Версия>1 И Скидка.Подарок Тогда
		Возврат "подарок";
		
	ИначеЕсли ПараметрыСеанса.Версия>1 И Скидка.ПереключитьТипЦен Тогда
		Возврат Скидка.ТипЦен.Наименование;
		
	ИначеЕсли НЕ Скидка.Суммовая Тогда
		Возврат Строка(Скидка.Значение) + "%";
		
	ИначеЕсли РежимСумма Тогда
		Возврат Формат(Скидка.Значение,"ЧЦ=10;ЧДЦ=2") + "р.";
		
	Иначе
		Возврат "сум.";
		
	КонецЕсли;
	
КонецФункции

// Описание функции
//
// Параметры:
//	Параметр1	- описание
//
// Возвращаемое значение:
//	Тип.Вид		- описание
//
Функция ОкруглитьЧисло(ЧислЗнач,Правило) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Правило) Тогда
		Возврат ЧислЗнач;
	КонецЕсли;
	
	Если ЧислЗнач<0 Тогда
		Знак=-1;
		ЧислЗнач=-ЧислЗнач;
	Иначе
		Знак=1;
	КонецЕсли;
	
	Результат=ЧислЗнач/Правило.Кратность;
	
	Если Результат<>Цел(Результат) Тогда
		Режим=Правило.Режим;    
		Если Режим=3 Тогда  // по правилам
			Режим=?(Результат-Цел(Результат)<0.5, 1, 2); 
		КонецЕсли;
		Результат=?(Режим=1, Цел(Результат), Цел(Результат)+1 );
	КонецЕсли;
	
	Возврат Результат*Правило.Кратность*Знак;
КонецФункции

// Возвращает структуру со значениями реквизитов регистра "Цены"
//
// Параметры:
//	Товар		- ссылка на товар
//  ТипЦен		- ссылка на тип цен, по умолчанию Розничная
//  ДатаЦены	- дата цены, по умолчанию РабочаяДата
//
// Возвращаемое значение:
//	Структура с полями "Цена", "Валюта"
//
Функция ЦенаТовара(Товар, ТипЦен=Неопределено, ДатаЦены=Неопределено) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ТипЦен) Тогда
		ТипЦен=Справочники.ТипыЦен.Розничная;
	КонецЕсли; 
	Если НЕ ЗначениеЗаполнено(ДатаЦены) Тогда
		ДатаЦены=ПолучитьРабочуюДату();
	КонецЕсли; 
	
	Отбор = Новый Структура("ТипЦен,Номенклатура", ТипЦен, Товар.Номенклатура);
	
	Возврат РегистрыСведений.ЦеныНоменклатуры.ПолучитьПоследнее(ДатаЦены, Отбор);
	
КонецФункции

// Преобразование строки шаблона содержащего выражения в [] (как в семерке) к строке для функции Вычислить()
// Заменяет квадратные скобки на операции соединения строк
// Многострочный текст преобразуется в одну строку, переводы строк будут возвращены на этапе вычисления
Функция Шаблон2Выражение(СтрШаблон) Экспорт
	
	Стр	= """" + СтрШаблон + """";
	Стр	= СтрЗаменить(Стр, "[", """+");
	Стр	= СтрЗаменить(Стр, "]", "+""");
	Стр	= СтрЗаменить(Стр, Символы.ПС, """+Символы.ПС+""");
	
	Возврат Стр;
КонецФункции

// Преобразование Многострочного текста в одну строку, переводы строк заменяет требуемым знаком
// 
Функция УдалитьПереводыСтрок(СтрШаблон, ЗнакЗамены = Неопределено) Экспорт
	
	Если ЗнакЗамены = Неопределено Тогда
		ЗнакЗамены = " ";
	ИначеЕсли СтрДлина(ЗнакЗамены) <= 1 Тогда
		ЗнакЗамены = ЗнакЗамены + " ";
	КонецЕсли;
	
	Стр	= СтрШаблон;
	Стр	= СтрЗаменить(Стр, Символы.ПС, ЗнакЗамены);
	
	Возврат Стр;
КонецФункции

// Преобразует RGB-представление цвета в абсолютное
// Можно передать значение типа цвет, или 3 числа - RGB компоненты цвета
Функция ЦветRGB2Число(Знач R,Знач G=Неопределено,Знач B=Неопределено) Экспорт
	
	// передано одно значение типа Цвет
	Если G=Неопределено Тогда
		G = R.G;
		B = R.B;
		R = R.R;
	КонецЕсли; 
	
	Возврат B*256*256 + G*256 + R; 
	
КонецФункции

// Преобразует абсолютное представление цвета в структуру RGB
//
Функция ЦветЧисло2RGB(Знач ЦветЧисло) Экспорт
	
	ЦветRGB = Новый Структура("R,G,B",0,0,0);
	
	ЦветRGB.B = Цел(ЦветЧисло/256/256);
	ЦветЧисло = ЦветЧисло - ЦветRGB.B*256*256;
	
	ЦветRGB.G = Цел(ЦветЧисло/256);
	ЦветRGB.R = ЦветЧисло - ЦветRGB.G*256;
	
	Возврат ЦветRGB; 
	
КонецФункции

// Проверка на вхождение значения в заданный диапазон
// Диапазон может задаваться как обоими границами, так и любой одной
// Также может быть диапазон с переходом через 0 (актуально для времени)
Функция ЗначениеВДиапазоне(ПровЗнач, Граница1, Граница2) Экспорт
	
	ЕстьГраница1 = ЗначениеЗаполнено(Граница1);
	ЕстьГраница2 = ЗначениеЗаполнено(Граница2);
	
	Если ЕстьГраница1 И ЕстьГраница2 И Граница2<Граница1 Тогда
		// случай диапазона с переходом через 0
		Возврат ПровЗнач>=Граница1 ИЛИ ПровЗнач<=Граница2;
		
	ИначеЕсли ЕстьГраница1 И ПровЗнач<Граница1 Тогда
		Возврат Ложь;
		
	ИначеЕсли ЕстьГраница2 И ПровЗнач>Граница2 Тогда
		Возврат Ложь;
		
	Иначе
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

// Заменяет в переданной дате Год, Месяц, День на 1, оставляя время неизменным
//
Функция ВремяИзДаты(ДД) Экспорт
	
	Возврат Дата(1,1,1, Час(ДД), Минута(ДД), Секунда(ДД) );
	
КонецФункции

// Заменяет в переданной дате время из второго параметра
//
Функция УстановитьВремяВДате(ДД,ВВ) Экспорт
	
	Возврат Дата( Год(ДД), Месяц(ДД), День(ДД), Час(ВВ), Минута(ВВ), Секунда(ВВ) );
	
КонецФункции

// Добавляет к дате заданное кол-во дней
//
Функция ДобавитьДень(ДД, КолвоДней) Экспорт
	
	Возврат ДД + КолвоДней * 24*60*60;
	
КонецФункции

Функция ВремяИзСтроки(стрВремя) Экспорт 
	ПозицияДвоеточия = СтрНайти(стрВремя, ":");
	Если ПозицияДвоеточия Тогда
		Час = Лев(стрВремя, ПозицияДвоеточия - 1);
		Минута = Сред(стрВремя, ПозицияДвоеточия + 1);
	Иначе 
		Час = стрВремя;
		Минута = "00";
	КонецЕсли;
	Попытка Час = Число(Час) Исключение Возврат '00010101235959' КонецПопытки;
	Попытка Минута = Число(Минута) Исключение Возврат '00010101235959' КонецПопытки;
	Час = Мин(Час,23);
	Минута = Мин(Минута, 59);
	Час = Формат(Час, "ЧЦ=2; ЧН=00; ЧВН=");
	Минута = Формат(Минута, "ЧЦ=2; ЧН=00; ЧВН=");
	Возврат Дата("00010101"+Час+Минута);

КонецФункции

	
// Преобразует количество минут в строку вида: 1д.20ч.45м.
//
Функция ВремяСтрокой(Знач КолвоМинут) Экспорт
	
	Стр="";
	
	кс=Цел(КолвоМинут/(24*60));
	Если кс>0 Тогда
		Стр=Стр+кс+"д.";
		КолвоМинут=КолвоМинут-кс*24*60;
	КонецЕсли;
	
	кч=Цел(КолвоМинут/60);
	Если кч>0 Тогда
		Стр=Стр+кч+"ч.";
		КолвоМинут=КолвоМинут-кч*60;
	КонецЕсли;
	
	Возврат Стр+КолвоМинут+"м.";
КонецФункции

// Функция преобразования десятичного числа в двоичное
//
Функция Число10в2(Число10) Экспорт
	
	Возврат ?( Число10<=1, Число10, Число( Строка(Число10в2(Цел(Число10/2))) + Строка(Число10%2) ) );
	
КонецФункции

// Описание функции
//
Функция ПроверитьЗначениеПоСписку(ПровЗначение, ТипОграничения, СписокВключенныхЗначений) Экспорт
	
	Если ТипОграничения = Перечисления.ТипыОграниченийПоСписку.Нет Тогда
		Возврат Истина;
	КонецЕсли;
	
	ЗначениеВСписке = СписокВключенныхЗначений.Найти(ПровЗначение) <> Неопределено;
	
	Возврат ТипОграничения = Перечисления.ТипыОграниченийПоСписку.Включить И ЗначениеВСписке
	ИЛИ
	ТипОграничения = Перечисления.ТипыОграниченийПоСписку.Исключить И НЕ ЗначениеВСписке
	
КонецФункции

Функция НайтиМестоПоКоду(КодМеста, ИнформационнаяБаза=Неопределено) Экспорт
	
	Если НЕ ПараметрыСеанса.РаспределенныйРежим Тогда
		Возврат Справочники.ПосадочныеМеста.НайтиПоКоду(КодМеста);
	КонецЕсли; 
	
	Если ИнформационнаяБаза = Неопределено Тогда
		ИнформационнаяБаза = ПараметрыСеанса.ТекущаяИБ;
	КонецЕсли; 
	
	Запрос = Новый Запрос("ВЫБРАТЬ 
	| Ссылка ИЗ Справочник.ПосадочныеМеста
	|ГДЕ
	|	ИнформационнаяБаза = &ИнформационнаяБаза И 
	|	Код = &Код
	|");
	
	Запрос.УстановитьПараметр("ИнформационнаяБаза", ИнформационнаяБаза);
	Запрос.УстановитьПараметр("Код", КодМеста);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	КонецЕсли; 
	
	Возврат Справочники.ПосадочныеМеста.ПустаяСсылка();
КонецФункции

// Возвращает стандартное наименование посадочного места
//
Функция НаимПосадочногоМеста(Место) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Место) Тогда
		Возврат ?(ПараметрыСеанса.Версия=3, "доставка", "");
	КонецЕсли;
	
	Возврат Место.Наименование;
	
КонецФункции


///////////////////////////////////////////////////////////////////////////////
// ФОРМИРОВАНИЕ ШТРИХ-КОДА

// Добавляет к базовому коду контрольный символ кода EAN
//
// Параметры:
//  БазовыйКод   - штрих-код (без контрольной цифры)
//  Тип          - тип штрих-кода: 13 - EAN13, 8 - EAN8
//
// Возвращаемое значение:
//  штрих-код с контрольным символом
//
Функция СформироватьШК(БазовыйКод, Тип=13) Экспорт
	
	Возврат БазовыйКод + КонтрольныйСимволEAN(БазовыйКод, Тип);
	
КонецФункции

// Функция вычисляет контрольный символ кода EAN
//
// Параметры:
//  БазовыйКод   - штрих-код (без контрольной цифры)
//  Тип          - тип штрих-кода: 13 - EAN13, 8 - EAN8
//
// Возвращаемое значение:
//  Контрольный символ штрих-кода
//
Функция КонтрольныйСимволEAN(БазовыйКод, Тип=13) Экспорт
	
	Четн   = 0;
	Нечетн = 0;
	
	КоличествоИтераций = ?(Тип = 13, 6, 4);
	
	Для Индекс = 1 По КоличествоИтераций Цикл
		Если (Тип = 8) и (Индекс = КоличествоИтераций) Тогда
		Иначе
			Четн   = Четн   + Сред(БазовыйКод, 2 * Индекс, 1);
		КонецЕсли;
		Нечетн = Нечетн + Сред(БазовыйКод, 2 * Индекс - 1, 1);
	КонецЦикла;
	
	Если Тип = 13 Тогда
		Четн = Четн * 3;
	Иначе
		Нечетн = Нечетн * 3;
	КонецЕсли;
	
	КонтЦифра = 10 - (Четн + Нечетн) % 10;
	
	Возврат ?(КонтЦифра = 10, "0", Строка(КонтЦифра));
	
КонецФункции


///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//  Заголовок      - заголовок сообщения об ошибке.
//
Процедура СообщитьОбОшибке(ТекстСообщения, Отказ = Ложь, Заголовок = "") Экспорт
	
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	Если ОкончаниеСлужебногоСообщения > 0 И Лев(ТекстСообщения, 1) = "{" Тогда
		ТекстСообщения = СокрЛП(Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2)));
	КонецЕсли;
	
	Отказ = Истина;
	
	Если ЗначениеЗаполнено(Заголовок) Тогда
		Сообщить(Заголовок);
		Заголовок = "";
	КонецЕсли;
	
	Сообщить(ТекстСообщения, СтатусСообщения.Важное);
	
КонецПроцедуры // СообщитьОбОшибке()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ВАЛЮТАМИ

#Если Клиент Тогда
	
	// Функция пересчитывает сумму из валюты ВалютаНач по курсу ПоКурсуНач 
	// в валюту ВалютаКон по курсу ПоКурсуКон.
	//
	// Параметры:      
	//  Сумма          - сумма, которую следует пересчитать.
	//  ВалютаНач      - ссылка на элемент справочника Валют;
	//                   определяет валюту, из которой надо пересчитывать.
	//  ВалютаКон      - ссылка на элемент справочника Валют;
	//                   определяет валюту, в которую надо пересчитывать.
	//  ПоКурсуНач     - курс, из которого надо пересчитать.
	//  ПоКурсуКон     - курс, в который надо пересчитать.
	//  ПоКратностьНач - кратность, из которого надо пересчитать (по умолчанию = 1).
	//  ПоКратностьКон - кратность, в который надо пересчитать (по умолчанию = 1).
	//
	// Возвращаемое значение: 
	//  Сумма, пересчитанная в другую валюту.
	//
	Функция ПересчетВалют(Сумма, ВалютаНач, ВалютаКон=Неопределено, ДатаКурса=Неопределено) Экспорт
		
		Если ВалютаКон=Неопределено Тогда
			ВалютаКон = Константы.ОсновнаяВалюта.Получить();
		КонецЕсли;
		
		Если Сумма = 0 ИЛИ ВалютаНач = ВалютаКон ИЛИ НЕ ЗначениеЗаполнено(ВалютаНач) ИЛИ НЕ ЗначениеЗаполнено(ВалютаКон) Тогда
			Возврат Сумма;
		КонецЕсли;
		
		Если ДатаКурса=Неопределено Тогда
			ДатаКурса = РабочаяДата;
		КонецЕсли;
		
		КурсНач = ПолучитьКурсВалюты( ВалютаНач, ДатаКурса );
		КурсКон = ПолучитьКурсВалюты( ВалютаКон, ДатаКурса );
		
		Если КурсНач.Курс=0 ИЛИ КурсНач.Кратность=0 ИЛИ
			КурсКон.Курс=0 ИЛИ КурсКон.Кратность=0 Тогда
			СообщитьОбОшибке("ПересчетВалют(): при пересчете обнаружен нулевой курс.");
			Возврат 0;
		КонецЕсли;
		
		Возврат Окр( Сумма * (КурсНач.Курс/КурсНач.Кратность) / (КурсКон.Курс/КурсКон.Кратность), 2);
		
	КонецФункции
	
#КонецЕсли

// Возвращает курс валюты на дату
//
// Параметры:
//  Валюта     - Валюта (элемент справочника "Валюты").
//  ДатаКурса  - Дата, на которую следует получить курс.
//
// Возвращаемое значение: 
//  Структура, содержащая:
//   Курс      - курс валюты.
//   Кратность - кратность валюты.
//
Функция ПолучитьКурсВалюты(Валюта, ДатаКурса) Экспорт
	
	Структура = РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ДатаКурса, Новый Структура("Валюта", Валюта));
	Возврат Структура;
	
КонецФункции

// Проверяет наличие установленного курса и кратности валюты на 1 января 1980 года.
// В случае отсутствия устанавливает курс и кратность равными единице.
//
// Параметры:
//  Валюта - валюта, корректность курса которой необходимо проверить.
//
Процедура ПроверитьКорректностьКурсаНа01_01_1980(Валюта) Экспорт
	
	ДатаКурса = Дата(1980, 1, 1);
	СтруктураКурса = ПолучитьКурсВалюты(Валюта, ДатаКурса);
	
	Если (СтруктураКурса.Курс = 0) Или (СтруктураКурса.Кратность = 0) Тогда
		
		// установка курса и кратности = 1 на 01.01.1980, чтобы не было ошибок при создании документов.
		
		РегистрКурсыВалют = РегистрыСведений.КурсыВалют.СоздатьМенеджерЗаписи();
		
		РегистрКурсыВалют.Период    = ДатаКурса;
		РегистрКурсыВалют.Валюта    = Валюта;
		РегистрКурсыВалют.Курс      = 1;
		РегистрКурсыВалют.Кратность = 1;
		РегистрКурсыВалют.Записать();
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьКорректностьКурсаНа01_01_1980()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного.
//
// Параметры:
//	ЗаданныйТип - тип, пустое значение которого нужно получить.
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа()

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт
	
	Если МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 
	
КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита. 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт
	
	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	Если ТабЧасть = Неопределено Тогда 
		// Нет такой табличной части в документе.
		Возврат Ложь;
	Иначе
		Если ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Функция проверяет наличие в строке только цифр.
//
// Параметры:
//  СтрокаПроверки - Строка для проверки только цифр.
//
// Возвращаемое значение:
//   Ложь - в строке содержатся только цифры, иначе - Истина.
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт
	
	СписокКодовЧисел = Новый СписокЗначений;
	Для а = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(а);
	КонецЦикла; 
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
				Возврат Истина;
			КонецЕсли; 
		КонецЦикла; 
		
	КонецЕсли; 
	
	Возврат Ложь;
	
КонецФункции 

//  Процедура определяет ситуацию, когда при изменении своей даты документ 
//  оказывается в другом периоде нумерации документов, и в это м случае
//  присваивает документу новый уникальный номер.
//
// Параметры:
//  ДокументОбъект         - контекст документа,из которого вызвана процедура.
//  НачальнаяДатаДокумента - начальная дата документа.
// 
Процедура ПроверитьНомерДокумента(ДокументОбъект, НачальнаяДатаДокумента) Экспорт 
	
	// Определяем назначенную для данного вида документов периодичность смены номера
	ПериодСменыНомера = ДокументОбъект.Метаданные().ПериодичностьНомера;
	
	//В зависимости от установленной периодичности смены номеров,
	//определяем разность старой и новой датами документа.
	Если ПериодСменыНомера = Метаданные.СвойстваОбъектов.ПериодичностьНомераДокумента.Год Тогда
		РазностьДат = НачалоГода(НачальнаяДатаДокумента) - НачалоГода(ДокументОбъект.Дата);
		
	ИначеЕсли ПериодСменыНомера = Метаданные.СвойстваОбъектов.ПериодичностьНомераДокумента.Квартал Тогда
		РазностьДат = НачалоКвартала(НачальнаяДатаДокумента) - НачалоКвартала(ДокументОбъект.Дата);
		
	ИначеЕсли ПериодСменыНомера = Метаданные.СвойстваОбъектов.ПериодичностьНомераДокумента.Месяц Тогда
		РазностьДат = НачалоМесяца(НачальнаяДатаДокумента) - НачалоМесяца(ДокументОбъект.Дата);
		
	ИначеЕсли ПериодСменыНомера = Метаданные.СвойстваОбъектов.ПериодичностьНомераДокумента.День Тогда
		РазностьДат = НачалоДня(НачальнаяДатаДокумента) - НачалоДня(ДокументОбъект.Дата);
		
	Иначе
		Возврат;
		
	КонецЕсли;
	
	Если РазностьДат <> 0 Тогда
		УстановитьНомерДокумента(ДокументОбъект);
	КонецЕсли;
	
КонецПроцедуры

// Процедура устанавливает номер документа.
//
// Параметры:
//  ДокументОбъект  - ДокументОбъект. Экземпляр документа, которому 
//                    необходимо присвоить новый номер.
//
Процедура УстановитьНомерДокумента(ДокументОбъект, Префикс = "") Экспорт
	
	ДокументОбъект.УстановитьНовыйНомер(Префикс);
	
КонецПроцедуры

// Проверяет правильность заполнения шапки документа.
// Если какой-то из реквизитов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  СтруктураШапкиДокумента    - структура, содержащая значения реквизитов документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеШапкиДокумента(СтруктураШапкиДокумента, СтруктураОбязательныхПолей, Отказ, Заголовок) Экспорт
	
	МетаданныеРеквизиты = СтруктураШапкиДокумента.Ссылка.Метаданные().Реквизиты;
	
	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл
		
		Значение = СтруктураШапкиДокумента[КлючЗначение.Ключ];
		Если ЗначениеНеЗаполнено(Значение) Тогда 
			
			Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;
			СообщитьОбОшибке(СтрокаСообщения, Отказ, Заголовок);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Документ - ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция ПредставлениеДокументаПриПроведении(Документ) Экспорт
	
	Возврат "Проведение документа: " + СокрЛП(Документ);
	
КонецФункции // ПредставлениеДокументаПриПроведении()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки=0) Экспорт
	
	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);
	
	Возврат Новый ОписаниеТипов("Строка", , КвалификаторСтроки);
	
КонецФункции

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность             - число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//  НеотрицательныеЧисла    - допустимый знак числа.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность=0, РазрядностьДробнойЧасти=0, НеотрицательныеЧисла=Ложь) Экспорт
	
	ДопустимыйЗнакЧисла = ?(НеотрицательныеЧисла, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой);
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ДопустимыйЗнакЧисла);
	
	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);
	
КонецФункции

// Служебная функция, предназначенная для получения описания типов даты.
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для даты указанной части даты.
//
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));
	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);
	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);
	
КонецФункции // ПолучитьОписаниеТиповДаты() 


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Функция возвращает имя табличной части, к которой принадлежит переданная строка.
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части.
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе.
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт
	
	ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
	Возврат ИмяТабличнойЧасти;
	
КонецФункции

// Функция возвращает имя перечисления по его значению
//
Функция ПолучитьИмяЗначенияПеречисления(Ссылка) Экспорт
	
	ИмяПеречисления = Ссылка.Метаданные().Имя;
	Индекс = Перечисления[ИмяПеречисления].Индекс(Ссылка);
	
	Возврат Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[Индекс].Имя;
	
КонецФункции // ПолучитьИмяЗначенияПеречисления()

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт
	
	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;
	
КонецФункции // ПолучитьСписокЭлементовПеречисления()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл
		
		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка" , ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата"   , ДокументОбъект.Дата);
	СтруктураШапкиДокумента.Вставить("Номер"  , ДокументОбъект.Номер);
	ИмяДокумента = ДокументОбъект.Метаданные().Имя;
	
	Для Каждого Реквизит Из Метаданные.Документы[ИмяДокумента].Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;
	
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  ИмяДокумента);
	
	Возврат СтруктураШапкиДокумента;
	
КонецФункции

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений - набор движений регистра.
//  ВидДвижения   - вид движения регистра накопления. 
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено) Экспорт
	
	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ВидДвижения <> Неопределено Тогда
		ТаблицаДвижений.ЗаполнитьЗначения(ВидДвижения, "ВидДвижения");
	КонецЕсли;
	
	Если НаборДвижений.мПериод <> '00010101' Тогда
		ТаблицаДвижений.ЗаполнитьЗначения(НаборДвижений.мПериод, "Период");
	КонецЕсли;		
	
	НаборДвижений.Загрузить(ТаблицаДвижений);
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ ФОРМАТИРОВАНИЯ И РАБОТЫ С ЧИСЛАМИ, СТРОКАМИ И ДАТАМИ

// Стандартная для данной конфигурации функция форматирования сумм.
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты.
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "0.00", ЧРГ = "") Экспорт
	
	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
	?(ЗначениеЗаполнено(ЧН), ";ЧН="+ЧН, "") +
	?(ЗначениеЗаполнено(ЧРГ), ";ЧРГ="+ЧРГ, "");
	
	РезультирующаяСтрока = Формат(Сумма, ФорматнаяСтрока);
	
	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + Валюта;
	КонецЕсли;
	
	Возврат РезультирующаяСтрока;
	
КонецФункции

// Возвращает отформатированное число, дополненное слева 
// пробелами до нужной длины
Функция ФорматСумм1(Сумма, НужнаяДлина) Экспорт
	
	Возврат СтрДополнитьСлева( ФорматСумм(Сумма), НужнаяДлина);
	
КонецФункции

// Дополняет строку пробелами слева до нужной длины 
// или обрезает, если исходная строка длиннее
Функция СтрДополнитьСлева(Знач Стр, НужнаяДлина) Экспорт
	
	ДлинаСтр = СтрДлина(Стр);
	Разница = НужнаяДлина - ДлинаСтр;
	
	Если Разница < 0 Тогда
		Возврат ?(НужнаяДлина=0, Стр, Лев(Стр, НужнаяДлина));
	КонецЕсли; 
	
	Для н=1 По Разница Цикл
		Стр = " "+Стр;
	КонецЦикла; 
	
	Возврат Стр;
КонецФункции

// Дополняет строку пробелами справа до нужной длины 
// или обрезает, если исходная строка длиннее
Функция СтрДополнитьСправа(Знач Стр, НужнаяДлина) Экспорт
	
	ДлинаСтр = СтрДлина(Стр);
	Разница = НужнаяДлина - ДлинаСтр;
	
	Если Разница < 0 Тогда
		Возврат ?(НужнаяДлина=0, Стр, Лев(Стр, НужнаяДлина));
	КонецЕсли; 
	
	Для н=1 По Разница Цикл
		Стр = Стр+" ";
	КонецЦикла; 
	
	Возврат Стр;
КонецФункции

// Возвращает текущую дату без времени в виде строки
//
Функция СтрТекДата() Экспорт
	
	Возврат Формат(ТекущаяДата(),"ДЛФ=Д");
	
КонецФункции

// Возвращает текущее время без даты в виде строки
//
Функция СтрТекВремя(БезСекунд=Ложь) Экспорт
	
	ТекВремя = Формат(ТекущаяДата(),"ДЛФ=В");
	
	Возврат ?(БезСекунд, Лев(ТекВремя,5), ТекВремя);
	
КонецФункции

// Возвращает рабочую дату.
//
// Возвращаемое значение:
//   Дата - рабочая дата.
//
Функция ПолучитьРабочуюДату() Экспорт
	
	#Если Клиент Тогда
		Возврат РабочаяДата;
	#Иначе
		Возврат ТекущаяДата();
	#КонецЕсли
	
КонецФункции

// Возвращает модуль числа.
//
// Параметры:
//  Число - число, к которому применяется функция.
//
// Возвращаемое значение:
//  Модуль числа.
//
Функция Модуль(Число) Экспорт
	
	Возврат ?(Число > 0, Число, -Число);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
//ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ ВНЕШНИХ ОБРАБОТОК

#Если Клиент Тогда
	
	//Получает внешнюю обработку из справочника.
	//
	//Параметры:
	//	ЭлементСправочника	- элемент справочника ВнешниеОбработки, из которого извлекается обработка.
	//
	//Возвращаемое значение:
	//	ВнешняяОбработка - извлеченная обработка.
	//
	Функция ПолучитьОбработкуИзСправочникаВнешнихОбработок(ЭлементСправочника, ВыборВнешнихОтчетов = Ложь) Экспорт
		
		//Извлечение обработки и сохранение ее как внешней.
		ДвоичноеПредставлениеОбработки = ЭлементСправочника.ХранилищеОбработки.Получить();
		
		Если ВыборВнешнихОтчетов Тогда
			ПолноеИмяФайла	= КаталогВременныхФайлов() + "СправочникВнешниеОбработки_ВнешнийОтчет.erf";
		Иначе
			ПолноеИмяФайла	= КаталогВременныхФайлов() + "СправочникВнешниеОбработки_ВнешняяОбработка.epf";
		КонецЕсли;
		
		ДвоичноеПредставлениеОбработки.Записать(ПолноеИмяФайла);
		
		Если ВыборВнешнихОтчетов Тогда
			Возврат ВнешниеОтчеты.Создать(ПолноеИмяФайла);
		Иначе
			Возврат ВнешниеОбработки.Создать(ПолноеИмяФайла);
		КонецЕсли;
		
	КонецФункции
	
#КонецЕсли

// Заполняет список обработок из справочника ВнешниеОбработки.
//
//Параметры:
//	СписокОбработок		 - список значений, который заполняется элементами справочника ВнешниеОбработки,
//	ВидОбработки		 - вид обработки, который является элементом перечисления ВидыОбработок,
//	ИмяМетаданных		 - наименование метаданных, на которые распространяется действие обработок. 
//						   Например: "Документ.ПриходнаяНакладная" или "РегистрНакопления.Взаиморасчеты".
//	ВставлятьРазделитель - флаг, указывающий на необходимость вставить разделитель между 
//						   исходным списком обработок и списком добавляемых обработок.
//  РазделительВСписке   - флаг, указывающий на тип добавляемого разделителя.
//
Процедура ЗаполнитьСписокОбработок(СписокОбработок, ВидОбработки, ИмяМетаданных = Неопределено, 
	ВставлятьРазделитель = Ложь, РазделительВСписке = Истина) Экспорт
	
	Запрос = Новый Запрос;
	
	// в зависимости от характера выбора данных происходит обращение или к элементам справочника ВнешниеОбработки 
	// или же к табличным частям элементов.
	Дополнение = ?(ИмяМетаданных = Неопределено,"",".Ссылка");
	
	Запрос.Текст = "ВЫБРАТЬ
	|	Таб.Ссылка КАК Обработка,
	|	Таб" + Дополнение + ".Наименование КАК Наименование
	|ИЗ
	|	Справочник.ВнешниеОбработки"+?(ИмяМетаданных = Неопределено,"",".ОбластьДействияОбработки")+" КАК Таб
	|ГДЕ
	|	Таб" + Дополнение + ".ПометкаУдаления = ЛОЖЬ
	|	И Таб" + Дополнение + ".ВидОбработки = &ВидОбработки";
	
	Запрос.УстановитьПараметр("ВидОбработки", ВидОбработки);			   
	
	Если ИмяМетаданных <> Неопределено Тогда			   
		Запрос.Текст = Запрос.Текст + "
		|	И Таб.ИмяМетаданных = &ИмяМетаданных";
		Запрос.УстановитьПараметр("ИмяМетаданных", ИмяМетаданных); 
	КонецЕсли;
	
	ВыборкаОбработок = Запрос.Выполнить().Выбрать();
	
	Если ВставлятьРазделитель И ВыборкаОбработок.Количество() <> 0 Тогда
		Если РазделительВСписке Тогда
			СписокОбработок.Добавить(0, "- - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
		Иначе
			СписокОбработок.Добавить(Неопределено);
		КонецЕсли;
	КонецЕсли;
	
	Пока ВыборкаОбработок.Следующий() Цикл
		СписокОбработок.Добавить(ВыборкаОбработок.Обработка, ВыборкаОбработок.Наименование);
	КонецЦикла;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ ВОЗМОЖНОСТИ РЕДАКТИРОВАНИЯ ДОКУМЕНТА

// Устанавливает отказ на проведение/отмену проведения документа 
// если его дата меньше даты запрета редактирования.
//
// Параметры:
//	Отказ  		- флаг отказа в проведении (отмене проведения) документа.
//  Объект 		- документ-объект,записываемый/проводимый. 
//	РежимЗаписи - режим записи документа (Запись,Проведение,ОтменаПроведения).
//
Процедура ПроверитьНаДатуЗапретаПередЗаписью(Отказ, Объект, РежимЗаписи) Экспорт
	
	Если Объект.Дата < Константы.ДатаЗапретаРедактирования.Получить()
		И РежимЗаписи <> РежимЗаписиДокумента.Запись Тогда
		
		Заголовок = Строка(Объект);
		
		Если РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
			ТекстСообщения = "Нельзя проводить документы с датой, более ранней," + Символы.ПС + 
			"чем дата запрета редактирования документов!";		
		Иначе
			ТекстСообщения = "Нельзя отменять проведение у документов с датой, более ранней," + Символы.ПС + 
			"чем дата запрета редактирования документов!";		
		КонецЕсли;
		
		СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок);
		
	КонецЕсли;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ВЫДАЧИ СООБЩЕНИЙ

// Выдает предупреждение или сообщение с заданным текстом.
//
// Параметры:
//  Текст      - текст предупреждения/сообщения.
//  ТихийРежим - выдается сообщение, независимо от режима работы.
//
Процедура ВыдатьПредупреждение(Текст, ТихийРежим = Ложь) Экспорт
	
	#Если Клиент Тогда
		Если ТихийРежим Тогда
			Сообщить(Текст, СтатусСообщения.Важное);
		Иначе
			Предупреждение(Текст);
		КонецЕсли;
	#Иначе
		Сообщить(Текст);
	#КонецЕсли
	
КонецПроцедуры

// Функция убирает из текста сообщения служебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт
	
	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
		
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);
	
КонецФункции


/////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ДЛЯ ВЫЗОВА ОБРАБОТКИ ЗАПУСКА ВНЕШНИХ ОТЧЕТОВ И ОБРАБОТОК

//Процедура вызывается из пункта меню "Сервис", действие "Внешние обработки".
//
Процедура ВызовВнешнихОбработок() Экспорт
	
	ВызовВнешнихОбработокОткрытьОбр(Ложь);
	
КонецПроцедуры

//Процедура вызывается из пункта меню "Отчеты", действие "Внешние отчеты".
//
Процедура ВызовВнешнихОтчетов() Экспорт
	
	ВызовВнешнихОбработокОткрытьОбр(Истина);
	
КонецПроцедуры

// Создает объект обработки и передает параметры
//
// Параметры:
//  ВыборВнешнихОтчетов (тип: булево), истина - обработка отображает внешние отчеты иначе внешние обработки 
//  
Процедура ВызовВнешнихОбработокОткрытьОбр(ВыборВнешнихОтчетов)
	
	Если ВыборВнешнихОтчетов Тогда
		КлючУникальности = "ВыборВнешнихОтчетов";
	Иначе
		КлючУникальности = "ВыборВнешнихОбработок";
	КонецЕсли;
	
	Форма = Обработки.ВызовВнешнихОбработок.ПолучитьФорму(,,КлючУникальности);
	Форма.ВыборВнешнихОтчетов = ВыборВнешнихОтчетов;
	Форма.Открыть();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С SMS-СООБЩЕНИЯМИ

// Определяет есть ли идентификаторы вида "%ИДЕНТИФИКАТОР%" в тексте сообщения
//
//	Параметры:
//		ИсходныйТекстСообщения (Строка) - исходный текст сообщения
//
//	Возвращаемое значение:
//		ИСТИНА - идентификаторы найдены, ЛОЖЬ - в противном случае
//
Функция ЕстьИдентификаторы(ИсходныйТекстСообщения) Экспорт
	
	ТекстШаблона = НРег(ИсходныйТекстСообщения);
	
	СписокИдентификаторов = Новый СписокЗначений;
	СписокИдентификаторов.Добавить("%клиент%");
	
	Для Каждого Элемент Из СписокИдентификаторов Цикл
		Если Найти(ТекстШаблона, Элемент.Значение) <> 0 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Определяет длину текста шаблона без идентификаторов
//
//	Параметры:
//		ИсходныйТекстСообщения (Строка) - исходный текст сообщения
//
//	Возвращаемое значение:
//		Тип: Число - длина текста шаблона без идентификаторов
//
Функция ДлинаБезИдентификаторов(ИсходныйТекстСообщения) Экспорт
	
	ТекстШаблона = НРег(ИсходныйТекстСообщения); 
	
	ДлинаСтр = СтрДлина(ТекстШаблона);
	
	СписокИдентификаторов = Новый СписокЗначений;
	СписокИдентификаторов.Добавить("%клиент%");
	
	Для Каждого Элемент Из СписокИдентификаторов Цикл
		
		ОстТекст = ТекстШаблона; 
		ДлинаИД = СтрДлина(Элемент.Значение);
		
		Пока СтрДлина(ОстТекст) > 0 Цикл 
			
			ПозицияИД = Найти(ОстТекст, Элемент.Значение);
			Если ПозицияИД <> 0 Тогда
				ДлинаСтр = ДлинаСтр - ДлинаИД;		
				ОстТекст = Прав(ОстТекст, СтрДлина(ОстТекст)- (ПозицияИД + ДлинаИД) - 1);
			Иначе
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ДлинаСтр; 
	
КонецФункции

// Определяет заполнено ли переданное значение
//
// Параметры: 
//  Значение - значение, заполнение которого надо проверить.
//
// Возвращаемое значение:
//  Истина - значение не заполнено, ложь - иначе.
//
Функция ЗначениеНеЗаполнено(Значение) Экспорт
	
	Результат = Ложь;
	ТипЗначения = ТипЗнч(Значение);
	
	// Сначала примитивные типы
	Если Значение = Неопределено Тогда
		Результат = Истина;
	ИначеЕсли Значение = NULL Тогда
		Результат = Истина;
	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Если СокрЛП(Значение) = "" Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Если Значение = 0 Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Результат = Ложь; // Булево будем считать не пустым
		
		//Отдельное определение, так как конструкторов данного типа не существует
	ИначеЕсли ТипЗначения = Тип("РежимПроведенияДокумента") Тогда
		Если Значение = РежимПроведенияДокумента.Неоперативный или Значение = РежимПроведенияДокумента.Оперативный тогда
			Результат = Ложь;
		КонецЕсли;
		
		// Для остальных будем считать значение пустым, если оно равно
		// значению по умолчанию своего типа
	Иначе
		Если Значение = Новый(ТипЗначения) Тогда
			Результат = Истина;
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции // ЗначениеНеЗаполнено()

////////////////////////////////////////////////////////////////////////////////
// ПРОЧЕЕ

// Получить номер соединения первого пользователя
//
Функция ПолучитьНомерСоединенияПервогоПользователя() Экспорт
	
	Для каждого Соединение Из ПолучитьСоединенияИнформационнойБазы() Цикл
		Если Соединение.ИмяПриложения="1CV8" Тогда
			Возврат Соединение.НомерСоединения;
		КонецЕсли; 
	КонецЦикла;
	
КонецФункции

// Описание функции
//
// Параметры:
//	Параметр1	- описание
//
// Возвращаемое значение:
//	Тип.Вид		- описание
//
Функция Версия1С() Экспорт
	
	СисИнфо = Новый СистемнаяИнформация;
	Версия1С = "V"+СтрЗаменить(Лев(СисИнфо.ВерсияПриложения,3), ".", "");
	
	Возврат Версия1С;
КонецФункции

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассив(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
	КонецЕсли;
	
	ДлинаРазделителя = СтрДлина(Разделитель);
	
	Пока 1=1 Цикл
		
		Поз = Найти(Стр,Разделитель);
		Если Поз = 0 Тогда
			Если Стр <> ""  Тогда
				МассивСтрок.Добавить( (Стр) );
			КонецЕсли; 
			Возврат МассивСтрок;
		КонецЕсли;
		
		МассивСтрок.Добавить( ( Лев(Стр,Поз-1) ) );
		Стр = Сред(Стр,Поз+ДлинаРазделителя);
		
	КонецЦикла;
	
КонецФункции

// Возвращает строку, полученную из массива элементов, разделенных символом разделителя
//
// Параметры:
//  Массив - Массив - массив элементов из которых необходимо получить строку
//  Разделитель - Строка - любой набор символов, который будет использован как разделитель между элементами в строке
//
// Возвращаемое значение:
//  Результат - Строка - строка, полученная из массива элементов, разделенных символом разделителя
// 
Функция ПолучитьСтрокуИзМассива(Массив, Разделитель = ",") Экспорт
	
	// возвращаемое значение функции
	Результат = "";
	
	Для Каждого Элемент ИЗ Массив Цикл
		
		Подстрока = ?(ТипЗнч(Элемент) = Тип("Строка"), Элемент, Строка(Элемент));
		
		РазделительПодстрок = ?(ПустаяСтрока(Результат), "", Разделитель);
		
		Результат = Результат + РазделительПодстрок + Подстрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Удаление строки с подстроками из дерева
// Заплатка по ошибке 1с, удаления многоуровневой строки из дерева
Процедура УдалитьСтрокуДерева(ТаблицаСтрок, СтрокаЗаказа) Экспорт
	
	// Предварительно удаляем все дочерние строки дерева
	Пока ЗначениеЗаполнено(СтрокаЗаказа.Строки) Цикл
		УдалитьСтрокуДерева(СтрокаЗаказа, СтрокаЗаказа.Строки[0]);
	КонецЦикла;
	
	ТаблицаСтрок.Строки.Удалить(СтрокаЗаказа);
	
КонецПроцедуры


Функция ДатаИзСтроки(стрДата) Экспорт
	Дата = стрДата; // строка 01.01.2016
	Дата = Дата(Сред(Дата,7,4),Сред(Дата,4,2),Сред(Дата,1,2));
	Возврат Дата;
КонецФункции


Функция ЗаписатьОбъектВФайл(ИмяФайла,Объект) экспорт
	ЗаписьJson = Новый ЗаписьJSON;
	ПараметрыЗаписи = Новый ПараметрыЗаписиJSON(,Символы.Таб);
	ЗаписьJson.ОткрытьФайл(ИмяФайла,,,ПараметрыЗаписи);
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJson,Объект,НазначениеТипаXML.Явное);
	ЗаписьJson.Закрыть();
	Возврат Истина;
КонецФункции

Функция ЗаписатьОбъектВстроку(Объект) экспорт
	ЗаписьJson = Новый ЗаписьJSON;
	ПараметрыЗаписи = Новый ПараметрыЗаписиJSON(,Символы.Таб);
	ЗаписьJson.УстановитьСтроку(ПараметрыЗаписи);
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJson,Объект,НазначениеТипаXML.Явное);
	Возврат ЗаписьJson.Закрыть();
КонецФункции

Функция ПрочитатьОбъектИзФайла(ИмяФайла) Экспорт
	ЧтениеJson = Новый ЧтениеJSON;
	ЧтениеJson.ОткрытьФайл(ИмяФайла);
	Объект = СериализаторXDTO.ПрочитатьJSON(ЧтениеJson);
	ЧтениеJson.Закрыть();
	Возврат Объект;
КонецФункции

Функция ПрочитатьОбъектИзСтроки(Строка) Экспорт
	ЧтениеJson = Новый ЧтениеJSON;
	ЧтениеJson.УстановитьСтроку(Строка);
	Объект = СериализаторXDTO.ПрочитатьJSON(ЧтениеJson);
	ЧтениеJson.Закрыть();
	Возврат Объект;
КонецФункции

&НаСервере
Функция ТекущаяДатаНаСервере() Экспорт
	Возврат ТекущаяДатаСеанса();
КонецФункции
#КонецЕсли

Функция УбратьВсеБуквы(Знач стрЧисло) Экспорт
	ТолькоЦифры = "";
	Если СтрДлина(стрЧисло)>=17 Тогда
		стрЧисло = Сред(стрЧисло, 4);		
	КонецЕсли;
	Для а=1 По СтрДлина(стрЧисло) Цикл
		Если СтрЧислоВхождений("1234567890",Сред(стрЧисло,а,1)) > 0 Тогда
			ТолькоЦифры = ТолькоЦифры + Сред(стрЧисло,а,1);
		КонецЕсли;
	КонецЦикла;
	Попытка
		Число = Число(ТолькоЦифры);
		ТолькоЦифры = Формат(Число, "ЧГ=0");
		
	Исключение
		ТолькоЦифры = "0";
	КонецПопытки;
	Возврат ТолькоЦифры;
КонецФункции

Функция Массив(П1, П2 = Неопределено, П3 = Неопределено, П4 = Неопределено, П5 = Неопределено, П6 = Неопределено, П7 = Неопределено, П8 = Неопределено, П9 = Неопределено, П10 = Неопределено, П11 = Неопределено, П12 = Неопределено, П13 = Неопределено) Экспорт
	Результат = Новый Массив;
	Результат.Добавить(П1);
	Если П2 <> Неопределено Тогда Результат.Добавить(П2) КонецЕсли;
	Если П3 <> Неопределено Тогда Результат.Добавить(П3) КонецЕсли;
	Если П4 <> Неопределено Тогда Результат.Добавить(П4) КонецЕсли;
	Если П5 <> Неопределено Тогда Результат.Добавить(П5) КонецЕсли;
	Если П6 <> Неопределено Тогда Результат.Добавить(П6) КонецЕсли;
	Если П7 <> Неопределено Тогда Результат.Добавить(П7) КонецЕсли;
	Если П8 <> Неопределено Тогда Результат.Добавить(П8) КонецЕсли;
	Если П9 <> Неопределено Тогда Результат.Добавить(П9) КонецЕсли;
	Если П10 <> Неопределено Тогда Результат.Добавить(П10) КонецЕсли;
	Если П11 <> Неопределено Тогда Результат.Добавить(П11) КонецЕсли;
	Если П12 <> Неопределено Тогда Результат.Добавить(П12) КонецЕсли;
	Если П13 <> Неопределено Тогда Результат.Добавить(П13) КонецЕсли;
	Возврат Результат;
КонецФункции

#Если НЕ ВнешнееСоединение Тогда
&НаСервере
Функция ДатаЗапускаТТ() Экспорт
	
	ДатаЗапускаТТ = ПланыОбмена.Основной.ЭтотУзел().ИнформационнаяБаза.ДатаЗапускаТТ;
	Если ЗначениеЗаполнено(ДатаЗапускаТТ) Тогда
		Возврат ДатаЗапускаТТ;
	КонецЕсли;
	Connection = SQL.ПодключитьсяКloyality_ext();
	
	//обертываем в транзакцию и выставляем флаг обработки, чтобы на период обработки строки очереди, запись в очереди была "заблокирована"
	ТекстЗапроса = "
	|SELECT  CONST_VAL
	|FROM    Loyality_ext.dbo.CONST 
	|WHERE   CONST_NAME = 'Дата запуска СУП ККМ'";
	
	ТаблицаРезультат = SQL.ВыполнитьЗапросВыборки(Connection, ТекстЗапроса);
	
	Если ТаблицаРезультат = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если не ТаблицаРезультат.Количество() Тогда
		//Предупреждение("Не установлена дата запуска ТТ!");
		Возврат Неопределено;
	КонецЕсли;
	
	ДатаЗапускаТТ = ДатаИзСтроки(ТаблицаРезультат[0][0]);
	Если ЗначениеЗаполнено(ДатаЗапускаТТ) Тогда
		обИнформационнаяБаза = ПланыОбмена.Основной.ЭтотУзел().ИнформационнаяБаза.ПолучитьОбъект();
		обИнформационнаяБаза.ДатаЗапускаТТ = ДатаЗапускаТТ;
		обИнформационнаяБаза.Записать();
	КонецЕсли;
	Возврат ДатаЗапускаТТ;
КонецФункции
#КонецЕсли

Функция DecToAny(Знач тЗначение, тОснование = 2) Экспорт
  Возврат ОбщегоНазначенияПовтИсп._DecToAny(тЗначение, тОснование);
КонецФункции

Функция AnyToDec(Знач тЗначение, тОснование) Экспорт
    Возврат ОбщегоНазначенияПовтИсп._AnyToDec(тЗначение,тОснование);
КонецФункции

Функция Asc(value) Экспорт
	Возврат ОбщегоНазначенияПовтИсп._Asc(value);
КонецФункции

// Преобразует таблицу значений в массив структур.
// Может использоваться для передачи на клиент данных в том случае, если таблица
// значений содержит только такие значения, которые могут
// быть переданы с сервера на клиент.
//
// Полученный массив содержит структуры, каждая из которых повторяет
// структуру колонок таблицы значений.
//
// Не рекомендуется использовать для преобразования таблиц значений
// с большим количеством строк.
//
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений - исходная таблица значений.
//
// Возвращаемое значение:
//  Массив - коллекция строк таблицы в виде структур.
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

// Преобразует строку таблицы значений в структуру.
// Свойства структуры и их значения совпадают с колонками переданной строки.
//
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений - строка таблицы значений.
//
// Возвращаемое значение:
//  Структура - преобразованная строка таблицы значений.
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

Функция ХэшСтрокиТаблицыЗначений(СтрокаТаблицыЗначений) Экспорт
	#Если ТонкийКлиент Тогда
		Возврат Новый УникальныйИдентификатор;
	#Иначе 
		Если СтрокаТаблицыЗначений = Неопределено Тогда
			Возврат "";
		КонецЕсли;
		СтруктураСтроки = СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений);
		стрСтруктураСтроки = ЗначениеВСтрокуВнутр(СтруктураСтроки);
		
		
		Хеш = Новый ХешированиеДанных(ХешФункция.MD5);
		Хеш.Добавить(стрСтруктураСтроки);
		
		СтрокаХЭШ = НРег(СтрЗаменить(Хеш.ХешСумма," ",""));
		Возврат СтрокаХЭШ;
	#КонецЕсли
КонецФункции

#Если Не ТонкийКлиент Тогда
// Возвращает значения ресурсов/реквизитов из РС ЗаказДопИнф
//
// Параметры:
// 	ЗаказСсылка - ДокументСсылка.Заказ 	- заказ
// 	Атрибуты 	- Массив, Строка 			- строковые идентификаторы атрибутов (в массиве или строкой через ",")
// 
// Возвращаемое значение:
// 	Структура - идентификаторы атрибутов и их значения
//
Функция АтрибутыЗаказа(ЗаказСсылка, Знач Атрибуты) Экспорт 
	Если ТипЗнч(Атрибуты) = Тип("Массив") Тогда 
		стрПоля = СтрСоединить(Атрибуты,",");
	Иначе
		стрПоля = Атрибуты;
		Атрибуты = СтрРазделить(стрПоля, ",", Ложь)
	КонецЕсли;
	ТекстЗапроса = СтрШаблон("ВЫБРАТЬ %1 ИЗ РегистрыСведений.ЗаказДопИнф ГДЕ Заказ = &3аказ", стрПоля);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Заказ", ЗаказСсылка);
	ТЗ = Запрос.Выполнить().Выгрузить();
	Если Не ТЗ.Количество() Тогда
		ТЗ.Добавить();		
	КонецЕсли;
	стрТЗ = ТЗ[0];
	Результат = Новый Структура(стрПоля);
	Для Каждого Атрибут Из Атрибуты Цикл
		Результат[Атрибут] = стрТЗ[Атрибут];
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Пишет в РС ЗаказДопИнф
//
// Параметры:
// 	ЗаказСсылка 		- ДокументСсылка.Заказ 				 - заказ
// 	ЗначенияАтрибутов - Структура, Соответствие, ... - объект с именами свойств, совпадающими с именами свойств регистра ЗаказДопИнф
// 
// Возвращаемое значение:
// 	Неопределено
//
Функция УстановитьАтрибутыЗаказа(ЗаказСсылка, ЗначенияАтрибутов)
	МЗ = РегистрыСведений.ЗаказДопИнф.СоздатьМенеджерЗаписи();
	МЗ.Заказ = ЗаказСсылка;
	МЗ.Прочитать();
	ВсеСвойства = ОбщегоНазначенияПовтИсп.СвойстваЗаказДопИнф(); //: ВсеСвойства = Новый Структура
	ЗаполнитьЗначенияСвойств(МЗ, ЗначенияАтрибутов,,"Заказ");	
	Если МЗ.Модифицированность() Тогда
		МЗ.Записать();
	КонецЕсли;
КонецФункции

// Пишет в РС ЗаказДопИнф
//
// Параметры:
// 	ЗаказСсылка 		- ДокументСсылка.Заказ 			 - заказ
//		Атрибут				- Строка								 - идентификатор атрибута
// 	Значение 			- Произвольный 
// 
// Возвращаемое значение:
// 	Неопределено
//
Функция УстановитьАтрибутЗаказа(ЗаказСсылка, Атрибут, Значение)
	МЗ = РегистрыСведений.ЗаказДопИнф.СоздатьМенеджерЗаписи();
	МЗ.Заказ = ЗаказСсылка;
	МЗ.Прочитать();
	МЗ[Атрибут] = Значение;
	МЗ.Записать();
КонецФункции


// Алиас к АтрибутыЗаказа()
//
// Параметры:
// 	ЗаказСсылка - ДокументСсылка.Заказ 	- заказ
// 	Атрибут	 	- Строка 					- идентификатор атрибута
// 
// Возвращаемое значение:
// 	Произвольный - значение атрибута
//
Функция АЗ(ЗаказСсылка, Атрибут) Экспорт
	Возврат АтрибутыЗаказа(ЗаказСсылка, Атрибут)[Атрибут];
КонецФункции


#КонецЕсли