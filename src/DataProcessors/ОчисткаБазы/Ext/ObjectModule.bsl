Перем ГлубинаАрхива Экспорт;
//
//
Процедура КомандаОчиститьИБ() Экспорт 
	
	Если НЕ ВыполнитьОчистку() Тогда
		ВывестиСообщение("Ошибка при выполнении очистки базы", Истина);
		Возврат;
	КонецЕсли;		
	
КонецПроцедуры	

//
//
Функция ПроверкаЗаполнения()
	
	// Указана ли ИБ
	Если ПараметрыСеанса.Версия > 1 И ПараметрыСеанса.РаспределенныйРежим И НЕ ЗначениеЗаполнено(ИнформационнаяБаза) Тогда
		ВывестиСообщение("Не указана информационная база для очистки!", Истина);
		Возврат Ложь;
	КонецЕсли;	
	
	// Указана ли дата обчистки
	Если НЕ ЗначениеЗаполнено(ДатаОчистки) Тогда
		ВывестиСообщение("Не указана дата до которой нужно произвести очистку!", Истина);
		Возврат Ложь;
	КонецЕсли;	
	
	// Нельзя устанавливать дату очистки будущим
	Если ДатаОчистки >= ТекущаяДата() Тогда
		ВывестиСообщение("Нельзя устанавливать дату очистки будущим числом!", Истина);
		Возврат Ложь;
	КонецЕсли;		
			
	Возврат Истина;
	
КонецФункции	

//
//
Функция УстановитьКомандуНаОчисткуИБРИБ() Экспорт
	
    Если НЕ ПроверкаЗаполнения() Тогда
		Возврат Ложь;
	КонецЕсли;	
	
	// Есть ли данные об очистке по текущей ИБ
	МенеджерЗаписи = РегистрыСведений.ОчисткаРИБ.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ИнформационнаяБаза = ИнформационнаяБаза;
	МенеджерЗаписи.Прочитать();
	
	// Уже есть команда на очистку и она еще не выполнена
	Если МенеджерЗаписи.Выбран() И НЕ МенеджерЗаписи.ОчисткаВыполнена Тогда
		ВывестиСообщение("Для ИБ " + ИнформационнаяБаза + " уже отправлена команда на очистку до " + МенеджерЗаписи.ДатаОчистки, Истина);
		Возврат Ложь;
	КонецЕсли;
	
		
	Возврат Истина;
	
КонецФункции

Процедура КомандаОтменитьОчисткуИБ() Экспорт
	
	// Отменяется очистка центрального узла
	Если ПланыОбмена.ГлавныйУзел() = Неопределено И ПараметрыСеанса.ТекущаяИБ = ИнформационнаяБаза Тогда
				
		// Передать команду на отмену очистки центральной и всех периферийных ИБ
		ВыборкаУзлов = ПланыОбмена.Основной.Выбрать();
		Пока ВыборкаУзлов.Следующий() Цикл
			Если ВыборкаУзлов.ПометкаУдаления Тогда
				Продолжить;
			КонецЕсли;
			ЗаписатьРегистрОтменаОчисткиИБ(ВыборкаУзлов.ИнформационнаяБаза);
		КонецЦикла;
		
	// Установить команду на очистку периферийной ИБ	
	Иначе
		ЗаписатьРегистрОтменаОчисткиИБ(ИнформационнаяБаза);
	КонецЕсли;
	
КонецПроцедуры	

// Прописать в регистр команду на очистку ИБ
//
Процедура ЗаписатьРегистрНаОчисткуИБ(ТекИБ, ОчититьПериферийнуюИБ = Истина)
	
	// Если это центральная ИБ то просто ставим контроль
	Контроль		= ПараметрыСеанса.ТекущаяИБ = ТекИБ;
	
	// Если это центральная ИБ и ОчититьПериферийнуюИБ = Ложь то для центральной все равно ставим метку Очистить.
	ОчиститьТекИБ	= ?(Контроль, Истина, ОчититьПериферийнуюИБ);
	
	МенеджерЗаписи = РегистрыСведений.ОчисткаРИБ.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ИнформационнаяБаза	= ТекИБ;
	МенеджерЗаписи.ДатаОчистки			= ДатаОчистки;
	МенеджерЗаписи.Очистить				= ОчиститьТекИБ;	
	МенеджерЗаписи.НомерСообщения		= 0;
	МенеджерЗаписи.Контроль				= Контроль;
	МенеджерЗаписи.ОчисткаВыполнена		= Ложь;
	МенеджерЗаписи.Записать();
	
	ВывестиСообщение("Установлена команда на очистку ИБ " + ТекИБ + " до " + ДатаОчистки);
	
КонецПроцедуры

// Прописать в регистр команду на очистку ИБ
//
Процедура ЗаписатьРегистрОтменаОчисткиИБ(ТекИБ)
	
	МенеджерЗаписи = РегистрыСведений.ОчисткаРИБ.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ИнформационнаяБаза	= ТекИБ;
	МенеджерЗаписи.Прочитать();
	
	Если МенеджерЗаписи.Выбран() Тогда
		
		МенеджерЗаписи.Удалить();
		//МенеджерЗаписи.ИнформационнаяБаза	= ТекИБ;
		//МенеджерЗаписи.ДатаОчистки			= Неопределено;
		//МенеджерЗаписи.НомерСообщения		= 0;
		//МенеджерЗаписи.Контроль				= Ложь;
		//МенеджерЗаписи.ОчисткаВыполнена		= Ложь;
		//МенеджерЗаписи.Записать();
		
		ВывестиСообщение("Отменена команда на очистку ИБ " + ТекИБ);
	КонецЕсли;
	
КонецПроцедуры


// Ввыполнить очистку текущей информационной базы
//
Функция ВыполнитьОчистку() Экспорт
	
	//----------------------------------------------
	// Проверки
	
    Если НЕ ПроверкаЗаполнения() Тогда
		Возврат Ложь;
	КонецЕсли;	
	
	// Уведомляем о начале очистки
	ВывестиСообщение("Пользователь " + Строка(ПараметрыСеанса.ТекущийПользователь) + " запустил обработку очистки базы до " + Строка(ДатаОчистки));
	ВывестиСообщение(Строка(ТекущаяДата()) + " начата очистка базы");
	
	ВывестиСообщение(Строка(ТекущаяДата()) + " Очистка SQL");
	ОчисткаSQL();
	//----------------------------------------------
	// Выбираем и помечаем на удаление документы всех видов
	Для Каждого Вид Из Метаданные.Документы Цикл
		УдаленияДокументов(Вид.Имя, Ложь);
	КонецЦикла;
	
	// Удаление данных из регистров при помеченном на удаление Заказе
	УдалениеДанныхРегистраСведенийСПроверкойРеквизита("ЗаказДопИнф", "Заказ");
	УдалениеДанныхРегистраСведенийСПроверкойРеквизита("ЗаказТоварыДопИнф", "Заказ");
	//----------------------------------------------
	// Удаленние данных из периодических регистров
	УдалениеДанныхПериодическогоРегистраСведений("ФактическийУчетРабочегоВремени"); 
	
	//----------------------------------------------
	// Удаленние данных из периодических регистров
	УдалениеДанныхПериодическогоРегистраСведений("КурсыВалют");
	УдалениеДанныхПериодическогоРегистраСведений("Цены");
	УдалениеДанныхПериодическогоРегистраСведений("ЦеныНоменклатуры");
	
	//----------------------------------------------
	// Выбираем и удаляем помеченные на удаление документы всех видов
	Для Каждого Вид Из Метаданные.Документы Цикл
		УдаленияДокументов(Вид.Имя);
	КонецЦикла;
	
	// Очистка закончена
	ВывестиСообщение(Строка(ТекущаяДата()) + " закончена очистка базы");
	
	Возврат Истина;
	
КонецФункции

// Проверка на наличиен не законченных очисток в периферийных ИБ
//
Функция ОчищеныПериферийныеИБ()
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	ОчисткаРИБ.ИнформационнаяБаза КАК ИнформационнаяБаза
	|ИЗ
	|	РегистрСведений.ОчисткаРИБ КАК ОчисткаРИБ
	|ГДЕ
	|	НЕ ОчисткаРИБ.ОчисткаВыполнена
	|	И ОчисткаРИБ.ИнформационнаяБаза <> &ЦентральнаяИБ";
	
	Запрос.УстановитьПараметр("ЦентральнаяИБ", ПараметрыСеанса.ТекущаяИБ);
	
	Если НЕ Запрос.Выполнить().Пустой() Тогда
		ВывестиСообщение("Существуют не выполненные команды на очистку периферийных баз", Истина);
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Удалить или пометить на удаление все документы определенного вида до указанной даты
//
Процедура УдаленияДокументов(ВидДокумента, УдалитьПомеченные = Истина)
	
	ВывестиСообщение(Строка(ТекущаяДата()) + ?(УдалитьПомеченные, " удаляются", " помечаются на удаление") + " документы " + ВидДокумента);
	
	Выборка = Документы[ВидДокумента].Выбрать( , ДатаОчистки);
	Инд = 1;
	Пока Выборка.Следующий() Цикл
		Если НЕ УдалитьПомеченные И Выборка.ПометкаУдаления Тогда
			Продолжить;
		ИначеЕсли УдалитьПомеченные И НЕ Выборка.ПометкаУдаления Тогда
			Продолжить;
		КонецЕсли;
		
		#Если Клиент Тогда
		ЕСли Инд%10 = 0 Тогда
			Состояние(""+Инд);
		КонецЕсли;
		#КонецЕсли
		Инд = Инд + 1;
		ТекОбъект = Выборка.ПолучитьОбъект();
		ТекОбъект.ДополнительныеСвойства.Вставить("ОчисткаБазы");
		
		Попытка
			Если УдалитьПомеченные Тогда
				ТекОбъект.Удалить();
			Иначе
				ТекОбъект.Проведен = Ложь;
				ТекОбъект.ПометкаУдаления = (Истина);
				ТекОбъект.ОбменДанными.Загрузка = ИСтина;
				ТекОбъект.Записать();
			КонецЕсли;
		Исключение
			Сообщить(ОписаниеОшибки());
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры	

// Очистить данные по регистру где помечен на удаление документ
//
Процедура УдалениеДанныхРегистраСведенийСПроверкойРеквизита(ВидРегистра, ПроверяемыйРеквизит)
	
	ВывестиСообщение(Строка(ТекущаяДата()) + " Очищается регистр сведений " + ВидРегистра);
	
	ТекстЗапроса = СтрШаблон("Выбрать * ИЗ РегистрСведений.%1 ГДЕ %2.Дата < &Дата Или %2.Дата is null", ВидРегистра, ПроверяемыйРеквизит);
	
	Запрос = Новый Запрос(ТекстЗапроса);	
	Запрос.УстановитьПараметр("Дата", ДатаОчистки);
	
	ТЗ = Запрос.Выполнить().Выгрузить();	
	МЗ = РегистрыСведений[ВидРегистра].СоздатьМенеджерЗаписи();
	Для Каждого Т Из ТЗ Цикл
		МЗ[ПроверяемыйРеквизит] = Т[ПроверяемыйРеквизит];
		МЗ.Прочитать();
		МЗ.Удалить();
		
	КонецЦикла;
КонецПроцедуры	

// Очистить периодический регистр сведений до указанной даты
//
Процедура УдалениеДанныхПериодическогоРегистраСведений(НаименованиеРегистра)
	
	ВывестиСообщение(Строка(ТекущаяДата()) + " Очищается регистр " + НаименованиеРегистра);
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	РегистрСведений." + НаименованиеРегистра + ".СрезПоследних КАК " + НаименованиеРегистра + "СрезПоследних
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	РегистрСведений." + НаименованиеРегистра + " КАК " + НаименованиеРегистра + "
	|ГДЕ
	|	" + НаименованиеРегистра + ".Период >= &Период"; 
	
	Запрос.УстановитьПараметр("Период", ДатаОчистки);
	
	ТаблицаОставляемыхЗаписей = Запрос.Выполнить().Выгрузить();
	
	НаборЗаписей = РегистрыСведений[НаименованиеРегистра].СоздатьНаборЗаписей();
	НаборЗаписей.Загрузить(ТаблицаОставляемыхЗаписей);
	НаборЗаписей.Записать();   	
	
КонецПроцедуры	

// Проставить признак об очистке центра для периферийных ИБ
//
Процедура ПроставитьОтметкуОбОчисткеЦентраДляПериферийныхИБ()
	
	ВыборкаОчисткиРИБ = РегистрыСведений.ОчисткаРИБ.Выбрать();
	
	ПроставленПризнак = Ложь;
	
	Пока ВыборкаОчисткиРИБ.Следующий() Цикл
		Если ВыборкаОчисткиРИБ.ИнформационнаяБаза = ПараметрыСеанса.ТекущаяИБ Тогда
			Продолжить;	
		КонецЕсли;
		МенеджерЗаписи = ВыборкаОчисткиРИБ.ПолучитьМенеджерЗаписи();
		МенеджерЗаписи.ИнформационнаяБаза	= МенеджерЗаписи.ИнформационнаяБаза;
		МенеджерЗаписи.ДатаОчистки			= МенеджерЗаписи.ДатаОчистки;
		МенеджерЗаписи.Очистить				= МенеджерЗаписи.Очистить;
		МенеджерЗаписи.НомерСообщения		= МенеджерЗаписи.НомерСообщения;
		МенеджерЗаписи.ОчисткаВыполнена		= МенеджерЗаписи.ОчисткаВыполнена;
		МенеджерЗаписи.Контроль				= МенеджерЗаписи.Контроль;
		МенеджерЗаписи.ОчищенаЦБ			= Истина;
		МенеджерЗаписи.Записать();
		
		ПроставленПризнак = Истина;
		
	КонецЦикла;

	Если ПроставленПризнак Тогда
	 	ВывестиСообщение("Проставлен признак очистки Центра для всех периферийных ИБ", Истина);
	КонецЕсли;
	
КонецПроцедуры

// Сообщить, предупредить, записать в журнал регистраций - по обстоятельствам
//
Процедура ВывестиСообщение(ТекстСообшения, ЭтоОшибка = Ложь)
	
	#Если Клиент Тогда
		Если глРабочееМесто = Неопределено Тогда
			Сообщить(ТекстСообшения, ?(ЭтоОшибка, СтатусСообщения.ОченьВажное, СтатусСообщения.БезСтатуса));
		КонецЕсли;
	#КонецЕсли
	
	ЗарегистрироватьСобытие(ТекстСообшения, ?(ЭтоОшибка, УровеньЖурналаРегистрации.Ошибка, УровеньЖурналаРегистрации.Информация));
	
КонецПроцедуры	

Процедура ОчисткаSQL() Экспорт
	Пакет="";
	
	Если Не ЗначениеЗаполнено(ГлубинаАрхива) Тогда
		ГлубинаАрхива = 62;
	КонецЕсли;
	ДатаОчистки = ТекущаяДата() - 86400*ГлубинаАрхива;
	
	RegExp = ирКэш.Получить().RegExp;
	Коннект = SQL.ПодключитьсяКsup_kkm(ИнформационнаяБаза);
	
	
	ОбъектыМД = Массив("Документ.ОтчетФО","Документ.Заказ","Документ.ПротоколРасчетов");
	СХ = ирОбщий.ПолучитьСтруктуруХраненияБДЛкс(ОбъектыМД,ИСтина);
	
	ШаблонЗапросаШапки = "begin tran
	|if object_id('tmp%1') is not null
	|	drop table tmp%1
	|
	|Select 
	|* 
	|into tmp%1
	|from %1
	|
	|
	|truncate table %1
	|
	|insert into %1 (%2)
	|select
	|%2
	|
	|from tmp%1
	|where %3 >= '%4'
	|
	|commit";    
	
	ШаблонЗапросаТЧ = "BEGIN TRAN
	|
	|if OBJECT_ID('tmp%1') IS NOT NULL
	|	DROP TABLE tmp%1
	|
	|SELECT 
	|	TP.* 
	|INTO tmp%1
	|
	|FROM %1 TP JOIN %5 
	|	ON TP.%5_IDRRef = %5._IDRRef
	|WHERE %3 >= '%4'
	|
	|
	|TRUNCATE TABLE %1
	|
	|INSERT INTO %1 (%2)
	|	SELECT
	|		%2
	|
	|FROM tmp%1
	|
	|COMMIT"; 
	
	СтруктураТЧ = СХ.НайтиСтроки(Новый Структура("Назначение", "ТабличнаяЧасть"));
	
	Для каждого Т Из СтруктураТЧ Цикл
		стрПоля = "";
		Для Каждого Поле Из Т.Поля Цикл
			стрПоля = стрПоля + ?(СтрПоля = "", "", ", ") + Поле.ИмяПоляХранения;
		КонецЦикла;
		RegExp.Pattern = "(_[a-zA-Z\d]+)\_VT\d+";
		Matches = RegExp.Execute(Т.ИмяТаблицыХранения);
		ТаблицаШапки = Matches.Item(0).SubMatches.Item(0);
		
		стрПоля = СтрЗаменить(стрПоля, "_Version,", "");
		ТекстЗапросаТЧ = СтрШаблон(ШаблонЗапросаТЧ, Т.ИмяТаблицыХранения, стрПоля, "_Date_Time", Формат(ДатаОчистки,"ДФ=yyyyMMdd"), ТаблицаШапки);
		Сообщить(ТекстЗапросаТЧ);		
		Пакет = Пакет + Символы.ПС + ТекстЗапросаТЧ;
	КонецЦикла;
	
	
	СтруктураШапки = СХ.НайтиСтроки(Новый Структура("Назначение", "Основная"));
	
	Для каждого Т Из СтруктураШапки Цикл
		стрПоля = "";
		Для Каждого Поле Из Т.Поля Цикл
			стрПоля = стрПоля + ?(СтрПоля = "", "", ", ") + Поле.ИмяПоляХранения;
		КонецЦикла;
		стрПоля = СтрЗаменить(стрПоля, "_Version,", "");
		ТекстЗапроса = СтрШаблон(ШаблонЗапросаШапки, Т.ИмяТаблицыХранения, стрПоля, "_Date_Time", Формат(ДатаОчистки,"ДФ=yyyyMMdd"));
		Сообщить(ТекстЗапроса);		
		ПАкет = Пакет + Символы.ПС + ТекстЗапроса;
	КонецЦикла;
	ОписаниеОшибки = "";
	Отказ = Ложь;
	Коннект.CommandTimeout = 9000;
	SQL.ВыполнитьЗапрос(Коннект, Пакет, Отказ, ОписаниеОшибки);
	Если Отказ Тогда
		ВызватьИсключение ОписаниеОшибки;
	КонецЕсли;
	//SQL.ВыполнитьЗапрос(Коннект, ТекстСкриптаОбслуживанияБД(), Отказ, ОписаниеОшибки);
	//Если Отказ Тогда
	//	ВызватьИсключение ОписаниеОшибки;
	//КонецЕсли;
КонецПроцедуры


Функция ТекстСкриптаОбслуживанияБД() Экспорт
	ТекстСкрипта = "-- Параметры скрипта
	|declare @database_names as nvarchar(max) = N''; -- имена баз задавать через запятую, если не заданы, то все несистемные базы
	|										  -- пока парсер примитивный - строка просто делится по запятым и обрезаются крайние пробелы
	|										  -- (если в имени базы будет запятая или в начале или конце имени пробел, то система не работает)
	|										  -- если указано ""-ИмяБазы"", то база будет исключена, 
	|declare @index_size_threshhold as int = 1024;   -- минимальный размер в КБ для перестраиваемого индекса. Нет смысла перестраивать индексы на десяток страниц
	|declare @index_rebuild_threshhold as numeric(5,2) = 25; -- показатель фрагментации, начиная с которого происходит перестроение индекса
	|declare @index_defrag_threshhold as numeric(5,2) = 12;  -- показатель фрагментации, начиная с которого происходит дефрагментация индекса
	|declare @index_rebuild_space_used_threshhold as numeric(5,2) = 50; -- процент заполненности страниц меньше которого требуется перестроение индекса
	|declare @timeout as int = 7200; -- максимальное время работы скрипта
	|declare @max_size as bigint = 536870912; -- максимальный суммарный обрабатываемый размер в КБ (чтобы не нагенерировать логов на терабайты) -- 512*1024*1024 КБ = 0,5 ТБ
	|declare @is_emulate as bit = 0; -- 0 - выполнять, 1 - только вывести команды
	|
	|set nocount on;
	|use master;
	|
	|declare @indexes as table (
	|	database_name nvarchar(128) not null,
	|	schema_name nvarchar(128) not null,
	|	table_name nvarchar(128) not null,
	|	index_name nvarchar(128) not null,
	|	is_clustered bit not null,
	|	size_kb bigint not null,
	|	fragmentation numeric(5,2) not null
	|	);
	|declare @database_names_table as table (
	|	name nvarchar(128) not null primary key
	|	);
	|if object_id('tempdb..#index_stats') is not null 
	|	drop table #index_stats;
	|create table #index_stats (
	|	database_id smallint not null,
	|	object_id int not null,
	|	index_id int not null,
	|	index_type_desc nvarchar(60) not null,
	|	avg_fragmentation_in_percent float not null,
	|	page_count bigint not null,
	|	avg_page_space_used_in_percent float not null,
	|	record_count bigint not null,
	|	index_name nvarchar(128),
	|	table_name nvarchar(128),
	|	schema_name nvarchar(128),
	|	db_name nvarchar(128)
	|	)
	|
	|print '-- ' + convert(nvarchar(max), getdate(), 121) + ' -- Поиск баз данных для обслуживания'
	|declare @timeout_datetime datetime = dateadd(second, @timeout, getdate());
	|
	|
	|-- Создание списка обслуживаемых БД по @database_names
	|with database_name_table(database_names_tail, database_name) as 
	|	(
	|		select 
	|			substring(@database_names, nullif(charindex(',', @database_names, 1), 0) + 1, len(@database_names) + 1), 
	|			rtrim(ltrim(left(@database_names, isnull(nullif(charindex(',', @database_names, 1), 0) - 1, len(@database_names)))))
	|		where 
	|			@database_names is not null 
	|		union all
	|		select 
	|			substring(database_names_tail, nullif(charindex(',', database_names_tail, 1), 0) + 1, len(database_names_tail) + 1), 
	|			rtrim(ltrim(left(database_names_tail, isnull(nullif(charindex(',', database_names_tail, 1), 0) - 1, len(database_names_tail)))))
	|		from database_name_table db
	|		where 
	|			database_names_tail is not null 
	|	), 
	|database_names_with_indicator(database_name, indicator) as
	|	(
	|		select
	|			db_name(db_id(case when database_name like '-%' then rtrim(ltrim(substring(database_name, 2, len(database_name)))) else database_name end)),
	|			case when database_name like '-%' then 1 else 0 end
	|		from database_name_table db 
	|		where db_name(db_id(case when database_name like '-%' then rtrim(ltrim(substring(database_name, 2, len(database_name)))) else database_name end)) is not null
	|	)
	|insert @database_names_table (name)
	|select name 
	|from sys.databases db
	|where 
	|db.name not in ('master', 'model', 'tempdb', 'msdb') -- системные базы данных обычно не требуется переиндексировать
	|and db.name not in (select dbi.database_name from database_names_with_indicator dbi where indicator = 1)
	|and ((select top 1 dbi.database_name from database_names_with_indicator dbi where indicator = 0) is null or 
	|	db.name in (select dbi.database_name from database_names_with_indicator dbi where indicator = 0))
	|;
	|print '-- ' + convert(nvarchar(max), getdate(), 121) + ' -- найдено ' + convert(nvarchar(max), @@rowcount) + ' баз данных для обслуживания'
	|
	|print '-- ' + convert(nvarchar(max), getdate(), 121) + ' -- Поиск индексов для обслуживания'
	|-- курсором обходим выбранные БД и ищем индексы и данные по их фрагментации
	|declare @database_cursor as cursor;
	|declare @current_database as nvarchar(128);
	|set @database_cursor = cursor forward_only for
	|select name from @database_names_table;
	|open @database_cursor;
	|fetch @database_cursor into @current_database;
	|
	|while (@@FETCH_STATUS = 0)
	|begin
	|	
	|	insert #index_stats
	|		(database_id, object_id, index_id, index_type_desc, avg_fragmentation_in_percent,
	|		page_count, avg_page_space_used_in_percent, record_count)
	|	select 
	|		database_id, object_id, index_id, index_type_desc, max(avg_fragmentation_in_percent),
	|		sum(page_count), sum(avg_page_space_used_in_percent*page_count)/isnull(nullif(sum(page_count),0),1), sum(record_count)
	|	from 
	|		sys.dm_db_index_physical_stats( db_id(@current_database), null, null, null, 'DETAILED') ips
	|	where 
	|		ips.index_id>0 -- убираем кучи (heap)
	|		and ips.index_type_desc in (N'CLUSTERED INDEX', N'NONCLUSTERED INDEX') -- всякие хитрые индексы не обрабатываем
	|		and ips.alloc_unit_type_desc = N'IN_ROW_DATA' -- обрабатываем только по ""обычным"" записям
	|		and ips.index_level = 0
	|	group by database_id, object_id, index_id, index_type_desc
	|	having sum(page_count)*8 >= @index_size_threshhold 
	|
	|	exec ('use [' + @current_database + '];
	|	update i
	|	set 
	|		i.db_name = db_name(),
	|		i.table_name = t.name,
	|		i.schema_name = s.name,
	|		i.index_name = ci.name
	|	from #index_stats i
	|	left join sys.tables t on i.object_id = t.object_id
	|	left join sys.schemas s on t.schema_id = s.schema_id
	|	left join sys.indexes ci on i.object_id = ci.object_id and i.index_id = ci.index_id
	|	where 
	|	i.database_id = db_id();');
	|
	|	fetch @database_cursor into @current_database;
	|end;
	|
	|use master;
	|close @database_cursor;
	|deallocate @database_cursor;
	|
	|declare @WithOptionsRebuild nvarchar(100) = 'WITH (SORT_IN_TEMPDB = ON); '; -- в Enterprise/Developer можно добавить в скобки "", ONLINE = ON""
	|
	|print '-- ' + convert(nvarchar(max), getdate(), 121) + ' -- Обработка найденных индексов'
	|-- Курсором обходим выбранные индексы и ищем те, которые надо обслуживать в порядке убывания размера (без упорядочнивания по БД!)
	|declare @index_cursor as cursor;
	|set @index_cursor = cursor forward_only for
	|select 
	|	'ALTER INDEX ' + i.index_name + ' ON [' + i.db_name + '].[' + i.schema_name + '].[' + i.table_name + '] ' + 
	|	case 
	|		when @index_rebuild_threshhold <= i.avg_fragmentation_in_percent then 'REBUILD ' + @WithOptionsRebuild
	|		when @index_rebuild_space_used_threshhold >= i.avg_page_space_used_in_percent then 'REBUILD ' + @WithOptionsRebuild
	|		when @index_defrag_threshhold <= i.avg_fragmentation_in_percent then 'REORGANIZE '
	|	end sql_command,
	|	case -- оценка влияния на журнал транзакций (неточная!)
	|		when @index_rebuild_threshhold <= i.avg_fragmentation_in_percent then i.page_count*8
	|		when @index_rebuild_space_used_threshhold >= i.avg_page_space_used_in_percent then i.page_count*8
	|		when @index_defrag_threshhold <= i.avg_fragmentation_in_percent then i.page_count*8*4*i.avg_fragmentation_in_percent/100
	|	end size
	|from #index_stats i
	|where 
	|	@index_rebuild_threshhold <= i.avg_fragmentation_in_percent or 
	|	@index_defrag_threshhold <= i.avg_fragmentation_in_percent or 
	|	@index_rebuild_space_used_threshhold >= i.avg_page_space_used_in_percent
	|order by i.page_count desc
	|
	|declare @database_id as smallint;
	|declare @object_id as int;
	|declare @index_id as int;
	|declare @partition_number as int;
	|declare @sql nvarchar(max);
	|declare @size numeric(20,4);
	|
	|open @index_cursor;
	|fetch @index_cursor into @sql, @size;
	|
	|print '-- ' + convert(nvarchar(max), getdate(), 121) + ' -- Начало обновления индексов' 
	|
	|while (@@FETCH_STATUS = 0)
	|begin
	|	set @max_size = @max_size - @size;
	|
	|	print '';
	|	print '-- ' + convert(nvarchar(max), getdate(), 121);
	|	print @sql;
	|	print '-- Размер индекса: ' + cast(@size as nvarchar(max));
	|	print '-- Остаток @max_size: ' + cast(@max_size as nvarchar(max));
	|
	|	if (@is_emulate = 0)
	|		exec(@sql);
	|
	|	if (@timeout_datetime<getdate())
	|	begin
	|		print '-- Выполнение прекращено по таймауту!';
	|		break;
	|	end;
	|	if (@max_size<0) 
	|	begin
	|		print '-- Достигнут предел обслуживаемого размера, выполнение прекращено!';
	|		break;
	|	end;
	|		
	|	fetch @index_cursor into @sql, @size;
	|end;
	|
	|print '-- ' + convert(nvarchar(max), getdate(), 121) + ' -- Окончание обновления индексов' 
	|
	|close @index_cursor;
	|deallocate @index_cursor;
	|
	|-- обновление частотных статистик
	|declare @dbstat_cursor as cursor;
	|set @dbstat_cursor = cursor forward_only for
	|select 'use [' + d.name + ']; exec sp_updatestats @resample = ''resample'';'
	|from @database_names_table d
	|
	|print '-- ' + convert(nvarchar(max), getdate(), 121) + ' -- Начало обновления частотных статистик'
	|
	|open @dbstat_cursor;
	|fetch @dbstat_cursor into @sql;
	|
	|while (@@FETCH_STATUS = 0)
	|begin
	|	
	|	print '';
	|	print '-- ' + convert(nvarchar(max), getdate(), 121);
	|	print @sql;
	|		
	|	if (@is_emulate = 0)
	|		exec(@sql);
	|
	|	if (@timeout_datetime<getdate())
	|	begin
	|		print '-- Выполнение прекращено по таймауту!';
	|		break;
	|	end;
	|	fetch @dbstat_cursor into @sql;
	|end;
	|
	|print '-- ' + convert(nvarchar(max), getdate(), 121) + ' -- Окончание обновления частотных статистик'
	|
	|if (@is_emulate = 1)
	|  select * from #index_stats i order by i.avg_fragmentation_in_percent desc
	|  
	|  
	|drop table #index_stats;
	|";
	Возврат ТекстСкрипта;
КонецФункции


ИнформационнаяБаза = ПараметрыСеанса.ТекущаяИБ;
Попытка
	ГлубинаАрхива = Константы.ГлубинаАрхива.Получить();	
Исключение
	ГлубинаАрхива = 0;
КонецПопытки;

Если Не ЗначениеЗаполнено(ГлубинаАрхива) Тогда
	ГлубинаАрхива = 62;
КонецЕсли;
ДатаОчистки = ТекущаяДата() - 86400*ГлубинаАрхива;